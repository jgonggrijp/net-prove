\documentclass[12pt,a4paper]{article}
\linespread{1.1}
\frenchspacing

\usepackage{amssymb} 
\usepackage{amsmath} 
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{proof}
\usepackage{mathabx}
\usepackage{xcolor}
\usepackage[british]{babel}

\usepackage{fontspec,xltxtra,xunicode}
\defaultfontfeatures{Mapping=tex-text}
\setromanfont{Palatino}
\setsansfont[Scale=MatchLowercase]{Helvetica}
\setmonofont[Scale=MatchLowercase]{FreeMono}

\usepackage{minted}
\usemintedstyle{netprovetermstyle}
\newmintedfile{haskell}{numbers=left,fontsize=\scriptsize}

\newcommand{\nd}[2]{#1 \vdash #2}
\newcommand{\Ra}{\rightarrow}
\newcommand{\lolli}{\multimap}
\newcommand{\bs}{\backslash}
\newcommand{\W}[1]{\textsf{#1}}
\newcommand{\ld}{\lambda}


\begin{document}

\title{Term derivation in automated proof nets for the Lambek-Grishin calculus}
\author{Julian Gonggrijp\thanks{Joint project with Niels Steenbergen and Maarten Trompper}}
\date{}
\maketitle


\section{Introduction}

The Lambek-Grishin calculus (LG) is an extension of Lambek calculus that has proven itself in the analysis of several context-sensitive natural language phenomena. sLG, a display sequent calculus for LG, has been shown to be tractable. \cite{m09} However, it allows for spurious ambiguity, requires explicit manipulation of sequents that are equivalent under structural rules and depends on a predetermined sequent structure. For the latter reason, sLG alone cannot be used to parse a sentence. Moortgat and Moot (2012) provided a proof net formalism for LG that solves all of these issues. \cite{mm12}

Automated theorem provers tend to work in ``sequent style'', searching top-down by backwards chaining. A theorem prover based on proofnets could work bottom-up instead and compute the proof structure---hence, parse a sentence---as a byproduct. To our knowledge, such a theorem prover was not yet built for LG. We decided to fill this gap using Haskell. The context for this endeavour was the 2014--2015 Master's course \emph{Logic and Language}, taught by Prof. dr. Michael Moortgat at Utrecht University\footnote{link}.

After defining a core datastructure as the interface between components of the theorem prover, we devided the remaining work into three subprojects that could be developed in parallel. Term derivation, the topic of the current paper, is one of those three subprojects. By the Curry-Howard isomorphism, every proof has a compact, algebraic representation called a term; since a proof net is also a proof, it follows that it can be represented with a term. The task of the author was to realise this for our Haskell implementation of LG proof nets. The term would then be available as a universal interface for further use; as a convenient proof representation to the human reader, as a source from which to reconstruct the display sequent version of the proof, or as the input material to a homomorphic mapping to another calculus in a categorial grammar setup. In particular, a CPS translation to MILL/LP has been shown to be worthwhile when LG is the source calculus. \cite{mm12}


\section{Project overview}\label{sec:project}

Every programming project starts with a specification. We decided that our theorem prover should initially at least be able to execute the following steps:
\begin{enumerate}
    \item let the user enter a sequence of words (unstructured), with the implicit request to prove that the words in the given order can form a grammatical sentence;
    \item look up the words in a lexicon and retrieve their associated syntactic types (LG formulae);
    \item generate a list with all possible proof structures for those formulae as detailed in \cite[p.~4--7]{mm12};
    \item filter the proof nets out of that list, applying the graph transformation rules described in \cite[p.~7--11]{mm12};
    \item compute all non-equivalent terms for each of those proof nets, following the procedure described in \cite[p.~21--26]{mm12};
    \item tell the user whether the given sequence of words was provable and if so, list the terms that were just computed as its possible interpretations.
\end{enumerate}
It was agreed that Maarten Trompper would implement step 3 \cite{maarten}, Niels Steenbergen would implement step 4 \cite{niels} and Julian Gonggrijp would implement step 5 (this paper). We first jointly designed the essential datastructures for formulae, terms and graphs and then each worked on our own components in parallel. Steps 1, 2 and 6 were left for later, to be taken up by whichever developer would turn out to finish his own component first. We also identified an extended ``wish list'' of features that should ultimately be included in a future version of our project:
\begin{itemize}
    \item visualisation of graphs;
    \item a \emph{large} lexicon;
    \item CPS translation of the terms from step 5 to MILL/LP for the derivational interpretation and thence to IL for the lexical interpretation, as explained in \cite[p.~14,19--21]{mm12};
    \item reconstruction of corresponding sequent-style proofs out of the terms from step 5, for sLG \cite[p.~3--4]{mm12} and fLG \cite[p.~15--18]{mm12};
    \item abstractions of the datastructures and algorithms to facilitate reuse of the proof net based approach for other logical calculi, for example LP with modal operators \cite{}.
\end{itemize}
In anticipation of the latter wish item, we allocated a ``Framework'' directory in advance.

We adopted the Cabal package format\footnote{link} from the beginning, in order to accomodate for future code reuse and deployment. Our project source code is freely available under the terms of the BSD license\footnote{link}, on GitHub\footnote{link, link, link}.


\section{Implementation}

\section{Results}

\subsection{Complexity analysis}

\subsection{Issues}

\section{Conclusion}

\subsection{Future work}


\begin{thebibliography}{9}
\end{thebibliography}


\appendix
\section{Source code}

\subsection{src/LG/Term.hs}
\haskellfile{../src/LG/Term.hs}

\subsection{src/LG/Subnet.hs}
\haskellfile{../src/LG/Subnet.hs}

\subsection{src/LG/SubnetGraph.hs}
\haskellfile{../src/LG/SubnetGraph.hs}

\subsection{src/LG/TestGraph.hs}
\haskellfile{../src/LG/TestGraph.hs}

\end{document}
